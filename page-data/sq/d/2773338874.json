{"data":{"allSanityPost":{"edges":[{"node":{"id":"-7e921be0-9397-57a5-96b8-14861d629d17","slug":{"current":"practicing-programming-through-problem-solving-part-2"},"title":"Practicing Programming Through Problem Solving (Part 2)","body":[{"children":[{"text":"It was hard to pick just one problem to go over this time. I have encountered numerous interesting problems in the last week of daily coding exercises.","marks":[]}]},{"children":[{"text":"The problem this week required me to look for some assistance, as I knew my initial plan would probably result in a TLE (Time Limit Exceeded). What was waiting for me in the discussion section blew my mind as it was an interesting way to approach using the strategy behind Binary Searching for a different kind of problem! It also made me more deeply consider that data structures and algorithms aren't set in stone. The thinking behind each of those items can be used to solve adjacent problems as well.","marks":[]}]},{"children":[{"text":"For background, the idea behind a Binary Search is that, given a sorted list of items, if you are looking for a specific item you can start by looking at the middle item in the list. If what you are looking for is less than the middle, you don't need the second half of the list any more. Rinse and repeat until you find the item. Binary Search is one of the quickest searching algorithms and has a O(log n) runtime. You can read more about Binary Search using this ","marks":[]},{"text":"GeeksforGeeks link","marks":["d8930c24a12a"]},{"text":".","marks":[]}]},{"children":[{"text":"This week's problem is ","marks":[]},{"text":"Longest Duplicate Substring","marks":["55686ac7e491"]},{"text":" on LeetCode. It asks you to find the longest substring of a string that appears more than once. For instance, using the example in the problem itself, the string \"banana\" has a substring of length 1 that occurs multiple times (two actually, \"a\" and \"n\"). But it also has a substring of length 2: \"an\" and \"na\". Realizing that substrings can overlap, you can also find one of length 3: \"ana\".","marks":[]}]},{"children":[{"text":"The brute force solution might consist of using a sliding window with a length one less than the length of the string and checking that against the whole string then reducing the window size by 1 and continuing until you find a repeated substring. The biggest issue with this, is if the biggest substring is length 2 or maybe doesn't even exist, the runtime is going to be around O(n^2). Because of this, it may not work on some of the trickier test cases. This is what was happening to me, and for a while I felt stuck.","marks":[]}]},{"children":[{"text":"After thinking about this problem for longer than I should have, I took a trip to the discussion section. This is where I saw Binary Search being used in a way I didn't really think of: determining the length of the substring. What this means is if we have a string of length 12, we can see (using a similar sliding window process to the brute force method) if a substring of length 6 exists (half of the original size). If so, try to find one that is half way between 6 and 12, which would be 9, if not, halfway between 0 (doesn't exist) and 6, which is 3. It was a neat application of 'halving' that is typically used in Binary Search.","marks":[]}]},{"children":[{"text":"On to the code!","marks":[]}]},{"children":[{"text":"First, let's just make a function that does the halving. In this case, that means we need to keep track of the 'left' and 'right' of the string, which would start as 0 and ","marks":[]},{"text":"len(string)","marks":["code"]},{"text":", as well as a placeholder for the result. This function will find the midpoint of 'left' and 'right', see if there is a substring with this length (which we can off-load to another function) and based on this result, determine if we try a longer or shorter substring:","marks":[]}]},{"children":[{"text":"left = 0\nright = size\nresult = \"\"","marks":["code"]}]},{"children":[{"text":"mid = (left + right) // 2\ntext = longest_substring_of_size(mid)\nif text:\n----result = text\n----left = mid + 1\nelse:\n----right = mid","marks":["code"]}]},{"children":[{"text":"If you can't tell, ","marks":[]},{"text":"mid","marks":["code"]},{"text":" is finding the midpoint of 'left' and 'right' (The ","marks":[]},{"text":"//","marks":["code"]},{"text":" operator divides and floors the result). The ","marks":[]},{"text":"longest_substring_of_size","marks":["code"]},{"text":" is a function that checks to see if a substring of the given size occurs more that once in the string, we will get to that in a bit. If the substring exists, we want to check the 'upper half' of substring sizes, so we hold onto the substring we found, just in case other size values don't work, and change the 'left' to the midpoint plus one (this effectively says: We had a left of 0 and a right of 12, we checked 6 (mid) and found a substring, so let's to it again with a left of 7 and a right of 12). If we could not find a substring of the given length, we check the 'lower half' of sizes (i.e. left is still 0 and right becomes 6).","marks":[]}]},{"children":[{"text":"You might notice that we are missing something. We need a loop so it keeps checking! In problems like this we usually keep going until the pointers (left and right) cross, so ","marks":[]},{"text":"while left < right","marks":["code"]},{"text":". There might be some other minor details, but this is the overall thinking behind this function.","marks":[]}]},{"children":[{"text":"Now let's tackle the ","marks":[]},{"text":"longest_substring_of_size","marks":["code"]},{"text":" function. It will be given a size and utilize a sliding window to see if a substring occurs more than once in the string. To keep track of what we found, let's use a set, because we don't need to hold on to multiple occurrences of a substring as when we find a second occurrence we are done. We will check every substring of the length we are given from the beginning to the end, which might look like this:","marks":[]}]},{"children":[{"text":"found = set()\nfor i in range(size - k + 1):\n----check = s[i:i + k]","marks":["code"]}]},{"children":[{"text":"The math in the ","marks":[]},{"text":"range","marks":["code"]},{"text":" is calculating what we consider the end, which is the length of the whole string, ","marks":[]},{"text":"size","marks":["code"]},{"text":", minus how large the sliding window is, plus one because range does not include the last number (0 to 2 would be 0 and 1). Similarly in the ","marks":[]},{"text":"check","marks":["code"]},{"text":" variable hold onto the substring we are checking, which starts at ","marks":[]},{"text":"i","marks":["code"]},{"text":" and is ","marks":[]},{"text":"k","marks":["code"]},{"text":" large. Once we have this substring, we see if it is in the set. If so, we found a substring that occurs twice and we can return it, if not we add it to the set and keep looking:","marks":[]}]},{"children":[{"text":"if check in found:\n----return check\nelse:\n----found.add(check)","marks":["code"]}]},{"children":[{"text":"Putting it all together, we have this code. Note that I added the two functions above inside of the LeetCode's given function, but if you adjusted the parameters of each function you could pull them out as well, it's just a style choice:","marks":[]}]},{"children":[{"text":"def longestDupSubstring(self, s: str) -> str:\n----size = len(s)\n\n----def longest_substring_of_size(k):\n--------found = set()\n--------for i in range(size - k + 1):\n------------check = s[i:i + k]\n------------if check in found:\n----------------return check\n------------else:\n----------------found.add(check)\n--------return None\n\n----def binary_search_size():\n--------left = 0\n--------right = size\n--------result = \"\"\n--------while left < right:\n------------mid = (left + right) // 2\n------------text = longest_substring_of_size(mid)\n------------if text:\n----------------result = text\n----------------left = mid + 1\n------------else:\n----------------right = mid\n--------return result\n\n----return binary_search_size()","marks":["code"]}]},{"children":[{"text":"And that is how I went about thinking through this problem! My solutions might not always be the most perfect solutions, but thinking through them and finding interesting new ways to utilize previous knowledge is super fun.","marks":[]}]},{"children":[{"text":"If you have any suggestions for how I could have improved this solution, feel free to drop me a line using the links in the footer.","marks":[]}]}],"author":{"name":"Dan Gaylord"},"mainImage":{"asset":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=910&h=607&auto=format","srcSet":"https://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?rect=0,0,910,606&w=320&h=213&auto=format 320w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=654&h=436&auto=format 654w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=768&h=512&auto=format 768w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=910&h=607&auto=format 910w","sizes":"(min-width: 910px) 910px, 100vw"}},"layout":"constrained","width":910,"height":607,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAABBv/EACEQAAICAgEEAwAAAAAAAAAAAAECAxEABCESEyIxMnGB/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/xAAYEQEBAAMAAAAAAAAAAAAAAAAAAQIRIf/aAAwDAQACEQMRAD8A4jbGgqDsxF5DwT08A4PVeGDruPm/kDRH1mzyFy6m+4oouD7/ADBEg67GvK6vHUVcuD7Emq0zEwFjdWWywc1rIwB9ZYJf/9k="}}}}}},{"node":{"id":"-2322b6be-c96a-564c-908d-aeff234bd4b9","slug":{"current":"practicing-programming-through-problem-solving-part-1"},"title":"Practicing Programming Through Problem Solving (Part 1)","body":[{"children":[{"text":"In the quest to improve to improve my algorithmic thinking and problem solving abilities, I've been doing many problems from various online resources. These posts will be a space for me to explain the thinking behind ","marks":[]},{"text":"a","marks":["em"]},{"text":" solution (but possibly not the most optimal one).","marks":[]}]},{"children":[{"text":"As I've been brushing up on my data structures, there is one data structure that scares me if it was ever one asked during a technical interview. That would be graphs. Not because I don't understand them, but the algorithms behind them take me longer to think about and put into practice. Trees on the other hand always seem way easy to me, probably because there's not always as much of a need to hold onto values. This post is, thankfully about trees and not graphs.","marks":[]}]},{"children":[{"text":"The problem in question this time is called ","marks":[]},{"text":"Sum of Nodes with Even-Valued Grandparent","marks":["3cfa54aaba1d"]},{"text":". You can go to the LeetCode page to learn more about it, but in summary the name pretty much explains itself. The only extra thing to consider is that if there are no even-numbered grandparents you should return 0 (which...makes sense).","marks":[]}]},{"children":[{"text":"Almost immediately when I read the problem I had ideas in my head. Do I want to use recursion? Breadth-first search? Depth-first search? Is this problem actually as easy as it sounds? (Side note: one weird feeling I get when doing problems on HackerRank and LeetCode is the difficulties don't always seem to be calibrated correctly. I've done many Medium problems that are pretty easy, and a couple Easy problems that may be on the edge of medium. Is it due to my knowledge or improper design? Who knows)","marks":[]}]},{"children":[{"text":"While I don't hate recursion (it's super useful a lot of the time), I wanted to go a non recursive route for this problem because other than the graph issue I mentioned above, dynamic programming (DP) is another topic I need practice on. While doing this problem with out recursion isn't exactly DP, I still wanted to be in a similar mindset.","marks":[]}]},{"children":[{"text":"After picking that method I also decided to try solving this using breath-first search (BST). While BST is usually used when looking for a shortest route or the like, that just came first in my head so I went with it. Once I solved it, I actually looked at other solutions and basically everyone else used depth-first search (DFS)! I guess I like being unique. (DFS is usually the pick when you want to 'touch' every node of a tree, but you technically don't need to go to every node so...)","marks":[]}]},{"children":[{"text":"Finally to the actual solution! To start off I double checked the constraints to make sure I didn't need to worry about being given an empty tree, always something you should look at because you don't want to stupidly fail test cases because you didn't think of the edge cases. After that I set up some initial variables, ","marks":[]},{"text":"result","marks":["code"]},{"text":" to keep track of the sum, and because I went with a BST also a ","marks":[]},{"text":"queue","marks":["code"]},{"text":" (in Python remember to import the ","marks":[]},{"text":"collections","marks":["code"]},{"text":" module to use the ","marks":[]},{"text":"deque","marks":["code"]},{"text":" function/data type:","marks":[]}]},{"children":[{"text":"result = 0\nqueue = collections.deque()","marks":["code"]}]},{"children":[{"text":"Next I got the queue and loop set up, which means adding the current root to it and having the loop continue while there are elements in the queue. Also some additional variables to make it easier to keep track of if a node has a left and/or right child (Note: my current build of this website makes tabs and multiple spaces tricky...something I need to work on :/):","marks":[]}]},{"children":[{"text":"queue.append(root)\nwhile queue:\n","marks":["code"]},{"text":"&emsp;","marks":[]},{"text":"leftNode = False\n","marks":["code"]},{"text":"&emsp;","marks":[]},{"text":"rightNode = False","marks":["code"]}]},{"children":[{"text":"Next I made sure that we grab the next element of the queue and check to see if it has children to add onto the queue, then also update the variables above (to save space, I just include the left child here, the right would be almost identical):","marks":[]}]},{"children":[{"text":"currNode = queue.popleft()\nif currNode.left and (currNode.left.left or currNode.left.right):\n    queue.append(currNode.left)\n    leftNode = True","marks":["code"]}]},{"children":[{"text":"You'll notice that the if statement also checks if the left child itself has children and wonder a) why and b) wouldn't that be a problem if the left child doesn't even exist!? Well, for anyone who is new to Python, it uses short-circuit operators, so if ","marks":[]},{"text":"currNode.left","marks":["code"]},{"text":" returned ","marks":[]},{"text":"False","marks":["code"]},{"text":", then the ","marks":[]},{"text":"and","marks":["code"]},{"text":" would have to be false so it doesn't even check the right side. I also checked the grandchildren here because there is no need to add a node to the queue if it doesn't have any grandchildren due to the expectation of the problem.","marks":[]}]},{"children":[{"text":"Next, a simple line of code to ensure we are only doing more work (calculating the results) if the node we are at (a grandparent) is an even value:","marks":[]}]},{"children":[{"text":"if currNode.val % 2 == 0:","marks":["code"]}]},{"children":[{"text":"Then finally, a set of nested ifs to make sure each child exists, has grandchildren, and if so add that grandchild's value to the result (again, just adding the left child code here):","marks":[]}]},{"children":[{"text":"if leftNode:\n    if currNode.left.left:\n        result += currNode.left.left.val\n    if currNode.left.right:\n        result += currNode.left.right.val","marks":["code"]}]},{"children":[{"text":"And don't forget this important line!","marks":[]}]},{"children":[{"text":"return result","marks":["code"]}]},{"children":[{"text":"With all that put together, here is the final solution:","marks":[]}]},{"children":[{"text":"import collections\n\nclass Solution:\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\n        result = 0\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            leftNode = False\n            rightNode = False\n            currNode = queue.popleft()\n            if currNode.left and (currNode.left.left or currNode.left.right):\n                queue.append(currNode.left)\n                leftNode = True\n            if currNode.right and (currNode.right.left or             currNode.right.right):\n                queue.append(currNode.right)\n                rightNode = True\n            if currNode.val % 2 == 0:\n                if leftNode:\n                    if currNode.left.left:\n                        result += currNode.left.left.val\n                    if currNode.left.right:\n                        result += currNode.left.right.val\n                if rightNode:\n                    if currNode.right.left:\n                        result += currNode.right.left.val\n                    if currNode.right.right:\n                        result += currNode.right.right.val\n        return result","marks":["code"]}]},{"children":[{"text":"And that is how I went about thinking through this problem! My solutions aren't always the most perfect solutions, and sometimes I admit that I need to look at the hints and/or discussions, but once you get that 'ah-ha' moment it's a thrill and code code starts to flow.","marks":[]}]},{"children":[{"text":"If you have any suggestions for how I could have improved this solution, feel free to drop me a line using the links in the footer.","marks":[]}]}],"author":{"name":"Dan Gaylord"},"mainImage":{"asset":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=910&h=607&auto=format","srcSet":"https://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?rect=0,0,910,606&w=320&h=213&auto=format 320w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=654&h=436&auto=format 654w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=768&h=512&auto=format 768w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=910&h=607&auto=format 910w","sizes":"(min-width: 910px) 910px, 100vw"}},"layout":"constrained","width":910,"height":607,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAABBv/EACEQAAICAgEEAwAAAAAAAAAAAAECAxEABCESEyIxMnGB/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/xAAYEQEBAAMAAAAAAAAAAAAAAAAAAQIRIf/aAAwDAQACEQMRAD8A4jbGgqDsxF5DwT08A4PVeGDruPm/kDRH1mzyFy6m+4oouD7/ADBEg67GvK6vHUVcuD7Emq0zEwFjdWWywc1rIwB9ZYJf/9k="}}}}}},{"node":{"id":"-5269b112-6ff4-5715-85c4-560f033c2160","slug":{"current":"becoming-a-better-coder"},"title":"Becoming a Better Coder","body":[{"children":[{"text":"They say anyone can code, and that's more or less true, but there is a large gap between people who can do it and people who can do it well","marks":[]}]},{"children":[{"text":"I've recently been trying to brush up on my coding skills, both because I haven't had as much time as I did in the past, and because I'm considering software engineering as a potential next step in my life. I've always loved to program, and have had many times when I thought I would make the shift, but I always got cold feet or thought 'It's not for me'. This time, though, I'm jumping into the deep end and putting my all in it. I cannot expect my knowledge from college and hobby programming to be enough, I need to do more.","marks":[]}]},{"children":[{"text":"With this in mind, I decided to reach out to some friends of mine that are software engineers to see what they recommended I do. There were a few major agreements:","marks":[]}]},{"children":[{"text":"Just program! Recruiters like to see that you've been working on something even if you don't do it for a living.","marks":[]}]},{"children":[{"text":"Try out a coding site like ","marks":[]},{"text":"HackerRank ","marks":["fc06649f605e"]},{"text":"or ","marks":[]},{"text":"LeetCode","marks":["d91036a3501a"]},{"text":". These show you some problems that could be similar to those seen in technical interviews and are good practice in general.","marks":[]}]},{"children":[{"text":"Find a good book to read and try solving problems 'by hand'. Specifically the book that was recommended to me was ","marks":[]},{"text":"\"Cracking the Coding Interview\"","marks":["40d36ff30505"]},{"text":" by Gayle Laakmann McDowell.","marks":[]}]},{"children":[{"text":"These resources have been great help for brushing up on CS topics I haven't seen in a while. They've also shown me how far I still need to go. It's a great feeling to take a problem from the \"Cracking the Coding Interview or coding websites and figure out a solution that works and is not the brute force method (although sometimes just knowing I can figure out the brute force can feel like a success story). The 'issues' come when trying to find the most optimal solutions. You see that some of your test cases have timed out or you look at other's solutions and see how much better/faster they are than yours. It's not the best of feelings, but seeing these other solutions is also something I can aspire to with practice and dedication.","marks":[]}]},{"children":[{"text":"Take for instance the sudoku project I've been working on (see my last post). Even though I have a solution (that works for most puzzles, although I haven't tested it on every puzzle ever...) it's probably far from optimal, so it'll be fun trying to improve it and take my learnings from the exercises I've been doing.","marks":[]}]},{"children":[{"text":"The only feedback I have about looking at other programmer's solutions, is that they write them for other programmers, not 'laymen'. If we want to bring more people into the field of computer science we should make sure we use variable names and comments that you doesn't need an expert to understand what is going on. That said, some topics in software development are pretty complex, and no variable names or comments will really be able to explain what is going on.","marks":[]}]},{"children":[{"text":"Image Note: Getting help writing clean code","marks":[]}]},{"children":[{"text":"Image credit: ","marks":[]},{"text":"\"Code washing\"","marks":["e4001a595d38"]},{"text":" by ","marks":[]},{"text":"Ezu","marks":["1389224cda53"]},{"text":" is licensed under ","marks":[]},{"text":"CC BY-NC-ND 2.0","marks":["bcf0f1171135"]}]}],"author":{"name":"Dan Gaylord"},"mainImage":{"asset":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://cdn.sanity.io/images/aaw5oc1t/production/315ab956c7afd8846fab0ac078c83410798d89c3-1024x819.jpg?w=1024&h=819&auto=format","srcSet":"https://cdn.sanity.io/images/aaw5oc1t/production/315ab956c7afd8846fab0ac078c83410798d89c3-1024x819.jpg?w=320&h=256&auto=format 320w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/315ab956c7afd8846fab0ac078c83410798d89c3-1024x819.jpg?w=654&h=523&auto=format 654w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/315ab956c7afd8846fab0ac078c83410798d89c3-1024x819.jpg?w=768&h=614&auto=format 768w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/315ab956c7afd8846fab0ac078c83410798d89c3-1024x819.jpg?w=1024&h=819&auto=format 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"}},"layout":"constrained","width":1024,"height":819,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAQABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAUGB//EAB8QAAEEAwEBAQEAAAAAAAAAAAMBAgQFAAYRIRIHMf/EABYBAQEBAAAAAAAAAAAAAAAAAAQAA//EABwRAAIDAQADAAAAAAAAAAAAAAECAAMRIRIiQf/aAAwDAQACEQMRAD8AYapUmudegzrC8t3lO3r0Q3GpjuZpVVLCgjzLJ4kX6aql6vcmfz7ZK8OpwBEmBaRg+K1zvUyrFscAkZz0mB+R+KqO8TuT0AeL5yZ12N7LvfkxPdZczXtik11XZTGRBc+EcRe+phiX9Osgy9wlljka8ao3jmr5/MMHbUA5wRVbEqNn/9k="}}}}}},{"node":{"id":"-446c0d4d-445e-5000-9edc-71b82cf1b98e","slug":{"current":"thinking-of-solving-sudokus"},"title":"Thinking of Solving Sudokus","body":[{"children":[{"text":"I've always been a huge fan of sudoku puzzles in their many iterations, so it was kind of a no-brainer for me to try to solve them 'once and for all'.","marks":[]}]},{"children":[{"text":"I remember the first time I saw a sudoku puzzle. It was in a newspaper I was looking at while I was at the table with my parents and the 'not-quite-math, but math' aspect of it just clicked with me. Having to logically determine which number goes where based solely on known information and following a set of rules resonated with my interest in programming, logic, mathematics, and, to an extent, gaming. It was a more refined Minesweeper that didn't feel unfair or require any guessing. It was also cool to see multiple kinds of sudokus, from the vanilla 9x9 with 3x3 regions, to those with not jigsaw shaped regions, some with diagonals and some with additional 3x3 regions (hyper-sudoku). There were even some that had variations on size or some where it was two or more connected puzzles.","marks":[]}]},{"children":[{"text":"Doing all these sudoku puzzles also opened up my puzzle worldview. Normally I only knew of the typical crosswords and logic puzzles, but there were so many others! Specifically sudoku introduced me to puzzles such as nonograms (picross), kenken, and Japanese puzzles created by ","marks":[]},{"text":"Nikoli","marks":["e48e57c0b7e2"]},{"text":". I spent much time trying all sorts of puzzles, which was great for my brain, but horrible for my time management.","marks":[]}]},{"children":[{"text":"Getting back to the subject of the matter. In 2016 when I was looking for a project to use to teach myself Python I figured why not try to create a program that solved sudoku puzzles. I figured I was pretty good at doing them myself (other than some of the harder ones), so how hard could it be to write a program to do it? Boy was I ","marks":[]},{"text":"almost","marks":["em"]},{"text":" wrong. There are a lot of way where we take for granted the way our brains work, and translating that into an algorithm is not always light work. But at the end of the day, I was able to put together a somewhat crude solution that represented a sudoku puzzle as a grid and did a whole bunch of work to solve them using lots of arrays and loops.","marks":[]}]},{"children":[{"text":"Fast forward to 2021 and I thought it was about time for me to update my old program. I knew I could do better both in terms of the structure and the logic. I first took to abstracting the problem. In my original iteration the program was technically one file with a class, but in my new version I decided to actually separate the files and create more classes. I went from just having a class that represents a sudoku cell, to also having a class for a sudoku region (a collection of cells) and a sudoku puzzle (a collection of regions) with each class having functions that do the appropriate work. I had a big \"A ha!\" moment when I was on a walk with my wife, son, and dog (one of many of these moments during walks) where I realized that sudoku columns and rows are just regions with specific meaning and they function just as the 3x3 grids, jigsaw shapes, or diagonals do. This also made me realize that generally most sudoku solving techniques are relegated to one region and and looking at the potential options for each cell.","marks":[]}]},{"children":[{"text":"There are many other things I can talk about, such as brainstorming ways to make the program require less computing time and space (thinking of you, Big-O) or adding additional solving techniques (currently it only does hidden singles and naked singles and pairs), but those stories might come at another time, as this post is getting long enough. For now, I'll keep hacking away at this 'problem' and doing more puzzles.","marks":[]}]},{"children":[{"text":"(Image Note: Bridging the gap between physical and digital sudoku)","marks":[]}]},{"children":[{"text":"Image credit:","marks":[]}]},{"children":[{"text":"\"Nixie sudoku\"","marks":["fcef5bb5270d"]},{"text":" by ","marks":[]},{"text":"TeaWithBuzz","marks":["0e6184fc75eb"]},{"text":" is licensed under ","marks":[]},{"text":"CC BY-NC-SA 2.0","marks":["fde754671c1a"]}]}],"author":{"name":"Dan Gaylord"},"mainImage":{"asset":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://cdn.sanity.io/images/aaw5oc1t/production/fe7108e6a26fb8d4ff50fae626df15c796b5e21b-1024x768.jpg?w=1024&h=768&auto=format","srcSet":"https://cdn.sanity.io/images/aaw5oc1t/production/fe7108e6a26fb8d4ff50fae626df15c796b5e21b-1024x768.jpg?w=320&h=240&auto=format 320w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/fe7108e6a26fb8d4ff50fae626df15c796b5e21b-1024x768.jpg?rect=1,0,1023,768&w=654&h=491&auto=format 654w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/fe7108e6a26fb8d4ff50fae626df15c796b5e21b-1024x768.jpg?w=768&h=576&auto=format 768w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/fe7108e6a26fb8d4ff50fae626df15c796b5e21b-1024x768.jpg?w=1024&h=768&auto=format 1024w","sizes":"(min-width: 1024px) 1024px, 100vw"}},"layout":"constrained","width":1024,"height":768,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAYHAQX/xAAiEAACAgIBBAMBAAAAAAAAAAABAwIEAAUxBhESIQciUbH/xAAUAQEAAAAAAAAAAAAAAAAAAAAE/8QAGREAAgMBAAAAAAAAAAAAAAAAAAEDEiER/9oADAMBAAIRAxEAPwDN/dt3lxVYC4izCLj4D2DnNt2ZbTTT0TErCHwIiQPYmODjd1VVpw3LpeUoFZC4qgOwEcXmL1ynLkHOEofcHtwfzCObeoSo8Iayu6uyaWDxmuRiQf0YZQPkHRg9RzfVjEKsri4Dj2ef5hiLsPRH/9k="}}}}}},{"node":{"id":"-6b17ccf2-eb42-5cf1-9a0a-62873ec7db2f","slug":{"current":"this-is-not-a-test"},"title":"This is (not) a Test","body":[{"children":[{"text":"Everything has a beginning, middle, and an end...hopefully this is just the beginning!","marks":[]}]},{"children":[{"text":"This site is a long time coming, and frankly should have been created ","marks":[]},{"text":"years","marks":["em"]},{"text":" ago when I first got into coding for fun. You'd think that taking computer science course all throughout high school and even ","marks":[]},{"text":"majoring","marks":["strong"]},{"text":" in CS would have prompted me to make a website to not only test out my skills, but also showcase my (amateurish) work. Everyone should have a place to show off what they can do, and while having a GitHub account (or whatever you use for your creative hobby) is probably sufficient, it's nice having a personalized place to house your works. Even if you cannot code and make a site like this one, plenty of tools exist for you to do it yourself!","marks":[]}]},{"children":[{"text":"Through any following musings I'll either share how I came to this point in my life (for those who want to learn from my mistake or like reading other people's 'journals') or talk about my foray into improving my coding skills. Feel free to join me for the ride or just check out whatever other stuff I feel like adding to this site. Please, stay a while and listen.","marks":[]}]},{"children":[{"text":"(Image Note: Not my actual workstation...but it looks nice doesn't it?)","marks":[]}]}],"author":{"name":"Dan Gaylord"},"mainImage":{"asset":{"gatsbyImageData":{"images":{"sources":[],"fallback":{"src":"https://cdn.sanity.io/images/aaw5oc1t/production/91ec5ddbf6d1426a2ee0dc89cd113d1d9f4aab3f-1920x1276.jpg?w=1920&h=1276&auto=format","srcSet":"https://cdn.sanity.io/images/aaw5oc1t/production/91ec5ddbf6d1426a2ee0dc89cd113d1d9f4aab3f-1920x1276.jpg?rect=2,0,1917,1276&w=320&h=213&auto=format 320w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/91ec5ddbf6d1426a2ee0dc89cd113d1d9f4aab3f-1920x1276.jpg?rect=1,0,1918,1276&w=654&h=435&auto=format 654w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/91ec5ddbf6d1426a2ee0dc89cd113d1d9f4aab3f-1920x1276.jpg?rect=0,0,1920,1275&w=768&h=510&auto=format 768w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/91ec5ddbf6d1426a2ee0dc89cd113d1d9f4aab3f-1920x1276.jpg?rect=1,0,1919,1276&w=1024&h=681&auto=format 1024w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/91ec5ddbf6d1426a2ee0dc89cd113d1d9f4aab3f-1920x1276.jpg?w=1366&h=908&auto=format 1366w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/91ec5ddbf6d1426a2ee0dc89cd113d1d9f4aab3f-1920x1276.jpg?w=1600&h=1063&auto=format 1600w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/91ec5ddbf6d1426a2ee0dc89cd113d1d9f4aab3f-1920x1276.jpg?w=1920&h=1276&auto=format 1920w","sizes":"(min-width: 1920px) 1920px, 100vw"}},"layout":"constrained","width":1920,"height":1276,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAANABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQDBQf/xAAjEAABAgUFAAMAAAAAAAAAAAABAgMABAURIQYHEiIxFGGB/8QAFQEBAQAAAAAAAAAAAAAAAAAAAgP/xAAWEQEBAQAAAAAAAAAAAAAAAAABEQD/2gAMAwEAAhEDEQA/AH95qHqeYMsmjT7jVPWODzbSexP5DW3um6lp/S7Uu6xycLvK8wc2PptGo/JVnqDbGYicUHAQpPsSokzKN1A5KTKFWU4L+9RiCHH+jhSL2H3BE5nd/9k="}}}}}}]}}}