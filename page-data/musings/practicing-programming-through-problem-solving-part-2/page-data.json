{
    "componentChunkName": "component---src-templates-post-js",
    "path": "/musings/practicing-programming-through-problem-solving-part-2",
    "result": {"pageContext":{"slug":"practicing-programming-through-problem-solving-part-2","id":"-7e921be0-9397-57a5-96b8-14861d629d17","title":"Practicing Programming Through Problem Solving (Part 2)","author":"Dan Gaylord","authorImage":{"images":{"sources":[],"fallback":{"src":"https://cdn.sanity.io/images/aaw5oc1t/production/9257269c7df6a7ad3f371262af1e8edb2d988f58-960x960.jpg?w=960&h=960&auto=format","srcSet":"https://cdn.sanity.io/images/aaw5oc1t/production/9257269c7df6a7ad3f371262af1e8edb2d988f58-960x960.jpg?w=320&h=320&auto=format 320w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/9257269c7df6a7ad3f371262af1e8edb2d988f58-960x960.jpg?w=654&h=654&auto=format 654w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/9257269c7df6a7ad3f371262af1e8edb2d988f58-960x960.jpg?w=768&h=768&auto=format 768w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/9257269c7df6a7ad3f371262af1e8edb2d988f58-960x960.jpg?w=960&h=960&auto=format 960w","sizes":"(min-width: 960px) 960px, 100vw"}},"layout":"constrained","width":960,"height":960,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAcEBQb/xAAlEAACAgEDBAEFAAAAAAAAAAABAgMEAAUGERITIVEHFDFBUmH/xAAXAQADAQAAAAAAAAAAAAAAAAADBAUB/8QAHxEAAQQCAgMAAAAAAAAAAAAAAQACAxEEBRITIWFx/9oADAMBAAIRAxEAPwCcfFmkpr176q5GEpxNwgPnuP8Aqc6+79o9u5qFyrLWRUHWaqNyV98Z6LY+3mg+OVMCJBq9eUu/Q4PWPxzmTU7U9PQ4tZuUVM78wuqDlyfeBnzpu8taaITEeJGI+Th4UYa8qyyK6cEMRxzjMVyuZrUspYqXYsR6xlhuSKFpAxNVojL11sJBNLGpQEhW45852NJuT6zti/FdkLdhCyMvhgR/cYyXsgO5x+IurJMLb9qK0qiW1llmZy5kYEg/fGMZtlEpf//Z"}},"published":"11/01/2021","categories":[{"title":"Programming","emoji":"üñ•Ô∏è"},{"title":"Learning","emoji":"üéì"}],"content":[{"_key":"1333e89ddbf6","_type":"block","children":[{"_key":"a9fbdfb5fa67","_type":"span","marks":[],"text":"It was hard to pick just one problem to go over this time. I have encountered numerous interesting problems in the last week of daily coding exercises."}],"markDefs":[],"style":"normal"},{"_key":"c452db031b32","_type":"block","children":[{"_key":"ad34f53afdbb","_type":"span","marks":[],"text":"The problem this week required me to look for some assistance, as I knew my initial plan would probably result in a TLE (Time Limit Exceeded). What was waiting for me in the discussion section blew my mind as it was an interesting way to approach using the strategy behind Binary Searching for a different kind of problem! It also made me more deeply consider that data structures and algorithms aren't set in stone. The thinking behind each of those items can be used to solve adjacent problems as well."}],"markDefs":[],"style":"normal"},{"_key":"38a921de87bf","_type":"block","children":[{"_key":"14a794d97ec6","_type":"span","marks":[],"text":"For background, the idea behind a Binary Search is that, given a sorted list of items, if you are looking for a specific item you can start by looking at the middle item in the list. If what you are looking for is less than the middle, you don't need the second half of the list any more. Rinse and repeat until you find the item. Binary Search is one of the quickest searching algorithms and has a O(log n) runtime. You can read more about Binary Search using this "},{"_key":"b5346d4546d2","_type":"span","marks":["d8930c24a12a"],"text":"GeeksforGeeks link"},{"_key":"e46be86f21b7","_type":"span","marks":[],"text":"."}],"markDefs":[{"_key":"d8930c24a12a","_type":"link","href":"https://www.geeksforgeeks.org/binary-search/"}],"style":"normal"},{"_key":"bcb74b546e1d","_type":"block","children":[{"_key":"63e108d2bb6b","_type":"span","marks":[],"text":"This week's problem is "},{"_key":"563b6cb71dd1","_type":"span","marks":["55686ac7e491"],"text":"Longest Duplicate Substring"},{"_key":"19db9a1fd8e5","_type":"span","marks":[],"text":" on LeetCode. It asks you to find the longest substring of a string that appears more than once. For instance, using the example in the problem itself, the string \"banana\" has a substring of length 1 that occurs multiple times (two actually, \"a\" and \"n\"). But it also has a substring of length 2: \"an\" and \"na\". Realizing that substrings can overlap, you can also find one of length 3: \"ana\"."}],"markDefs":[{"_key":"55686ac7e491","_type":"link","href":"https://leetcode.com/problems/longest-duplicate-substring/"}],"style":"normal"},{"_key":"44ce43a9fe56","_type":"block","children":[{"_key":"8a8692db929a","_type":"span","marks":[],"text":"The brute force solution might consist of using a sliding window with a length one less than the length of the string and checking that against the whole string then reducing the window size by 1 and continuing until you find a repeated substring. The biggest issue with this, is if the biggest substring is length 2 or maybe doesn't even exist, the runtime is going to be around O(n^2). Because of this, it may not work on some of the trickier test cases. This is what was happening to me, and for a while I felt stuck."}],"markDefs":[],"style":"normal"},{"_key":"60070e2039d0","_type":"block","children":[{"_key":"5c7c546a949a","_type":"span","marks":[],"text":"After thinking about this problem for longer than I should have, I took a trip to the discussion section. This is where I saw Binary Search being used in a way I didn't really think of: determining the length of the substring. What this means is if we have a string of length 12, we can see (using a similar sliding window process to the brute force method) if a substring of length 6 exists (half of the original size). If so, try to find one that is half way between 6 and 12, which would be 9, if not, halfway between 0 (doesn't exist) and 6, which is 3. It was a neat application of 'halving' that is typically used in Binary Search."}],"markDefs":[],"style":"normal"},{"_key":"b6513f7fc377","_type":"block","children":[{"_key":"4e0b64474040","_type":"span","marks":[],"text":"On to the code!"}],"markDefs":[],"style":"normal"},{"_key":"e1539b7a64ba","_type":"block","children":[{"_key":"251c50fb5bbf","_type":"span","marks":[],"text":"First, let's just make a function that does the halving. In this case, that means we need to keep track of the 'left' and 'right' of the string, which would start as 0 and "},{"_key":"060be18770d7","_type":"span","marks":["code"],"text":"len(string)"},{"_key":"c91e1d6c8195","_type":"span","marks":[],"text":", as well as a placeholder for the result. This function will find the midpoint of 'left' and 'right', see if there is a substring with this length (which we can off-load to another function) and based on this result, determine if we try a longer or shorter substring:"}],"markDefs":[],"style":"normal"},{"_key":"065c76bc4b40","_type":"block","children":[{"_key":"07aac58e0e9c","_type":"span","marks":["code"],"text":"left = 0\nright = size\nresult = \"\""}],"markDefs":[],"style":"normal"},{"_key":"ce44109a38c2","_type":"block","children":[{"_key":"bcbe54720da7","_type":"span","marks":["code"],"text":"mid = (left + right) // 2\ntext = longest_substring_of_size(mid)\nif text:\n----result = text\n----left = mid + 1\nelse:\n----right = mid"}],"markDefs":[],"style":"normal"},{"_key":"2a3db7be7e6f","_type":"block","children":[{"_key":"a9a5ba7d81c6","_type":"span","marks":[],"text":"If you can't tell, "},{"_key":"bf969f34b4af","_type":"span","marks":["code"],"text":"mid"},{"_key":"715ea225cb07","_type":"span","marks":[],"text":" is finding the midpoint of 'left' and 'right' (The "},{"_key":"e9898793fa00","_type":"span","marks":["code"],"text":"//"},{"_key":"599938d78606","_type":"span","marks":[],"text":" operator divides and floors the result). The "},{"_key":"60be473ee91a","_type":"span","marks":["code"],"text":"longest_substring_of_size"},{"_key":"a02af4972dcf","_type":"span","marks":[],"text":" is a function that checks to see if a substring of the given size occurs more that once in the string, we will get to that in a bit. If the substring exists, we want to check the 'upper half' of substring sizes, so we hold onto the substring we found, just in case other size values don't work, and change the 'left' to the midpoint plus one (this effectively says: We had a left of 0 and a right of 12, we checked 6 (mid) and found a substring, so let's to it again with a left of 7 and a right of 12). If we could not find a substring of the given length, we check the 'lower half' of sizes (i.e. left is still 0 and right becomes 6)."}],"markDefs":[],"style":"normal"},{"_key":"7ef8114a06eb","_type":"block","children":[{"_key":"55847cafb3e6","_type":"span","marks":[],"text":"You might notice that we are missing something. We need a loop so it keeps checking! In problems like this we usually keep going until the pointers (left and right) cross, so "},{"_key":"27f1a27309ac","_type":"span","marks":["code"],"text":"while left < right"},{"_key":"212c012f0fd2","_type":"span","marks":[],"text":". There might be some other minor details, but this is the overall thinking behind this function."}],"markDefs":[],"style":"normal"},{"_key":"c830b430cc6d","_type":"block","children":[{"_key":"bb56a35e2b35","_type":"span","marks":[],"text":"Now let's tackle the "},{"_key":"c2ab71b1bd61","_type":"span","marks":["code"],"text":"longest_substring_of_size"},{"_key":"327d41e08cc8","_type":"span","marks":[],"text":" function. It will be given a size and utilize a sliding window to see if a substring occurs more than once in the string. To keep track of what we found, let's use a set, because we don't need to hold on to multiple occurrences of a substring as when we find a second occurrence we are done. We will check every substring of the length we are given from the beginning to the end, which might look like this:"}],"markDefs":[],"style":"normal"},{"_key":"21e805f6b5c0","_type":"block","children":[{"_key":"c9cdc40683b6","_type":"span","marks":["code"],"text":"found = set()\nfor i in range(size - k + 1):\n----check = s[i:i + k]"}],"markDefs":[],"style":"normal"},{"_key":"8da8f1b6eba2","_type":"block","children":[{"_key":"8e607b610954","_type":"span","marks":[],"text":"The math in the "},{"_key":"33b9f8b8c23b","_type":"span","marks":["code"],"text":"range"},{"_key":"4a98d605d366","_type":"span","marks":[],"text":" is calculating what we consider the end, which is the length of the whole string, "},{"_key":"92cacfe6477f","_type":"span","marks":["code"],"text":"size"},{"_key":"ac2624a700d4","_type":"span","marks":[],"text":", minus how large the sliding window is, plus one because range does not include the last number (0 to 2 would be 0 and 1). Similarly in the "},{"_key":"a4293ed9683d","_type":"span","marks":["code"],"text":"check"},{"_key":"c8607ffa089e","_type":"span","marks":[],"text":" variable hold onto the substring we are checking, which starts at "},{"_key":"a4803cdb872a","_type":"span","marks":["code"],"text":"i"},{"_key":"86894439900f","_type":"span","marks":[],"text":" and is "},{"_key":"a89356d1d38a","_type":"span","marks":["code"],"text":"k"},{"_key":"9f266036b2f2","_type":"span","marks":[],"text":" large. Once we have this substring, we see if it is in the set. If so, we found a substring that occurs twice and we can return it, if not we add it to the set and keep looking:"}],"markDefs":[],"style":"normal"},{"_key":"a11c2d9ff5ed","_type":"block","children":[{"_key":"9af926f22fb0","_type":"span","marks":["code"],"text":"if check in found:\n----return check\nelse:\n----found.add(check)"}],"markDefs":[],"style":"normal"},{"_key":"c4a0580b1a7a","_type":"block","children":[{"_key":"c031671945ed","_type":"span","marks":[],"text":"Putting it all together, we have this code. Note that I added the two functions above inside of the LeetCode's given function, but if you adjusted the parameters of each function you could pull them out as well, it's just a style choice:"}],"markDefs":[],"style":"normal"},{"_key":"3eed2abda304","_type":"block","children":[{"_key":"65c93caaf100","_type":"span","marks":["code"],"text":"def longestDupSubstring(self, s: str) -> str:\n----size = len(s)\n\n----def longest_substring_of_size(k):\n--------found = set()\n--------for i in range(size - k + 1):\n------------check = s[i:i + k]\n------------if check in found:\n----------------return check\n------------else:\n----------------found.add(check)\n--------return None\n\n----def binary_search_size():\n--------left = 0\n--------right = size\n--------result = \"\"\n--------while left < right:\n------------mid = (left + right) // 2\n------------text = longest_substring_of_size(mid)\n------------if text:\n----------------result = text\n----------------left = mid + 1\n------------else:\n----------------right = mid\n--------return result\n\n----return binary_search_size()"}],"markDefs":[],"style":"normal"},{"_key":"8629391b7ad0","_type":"block","children":[{"_key":"bca8f6254a7f","_type":"span","marks":[],"text":"And that is how I went about thinking through this problem! My solutions might not always be the most perfect solutions, but thinking through them and finding interesting new ways to utilize previous knowledge is super fun."}],"markDefs":[],"style":"normal"},{"_key":"2b583dbeed36","_type":"block","children":[{"_key":"9c16afc8c89e","_type":"span","marks":[],"text":"If you have any suggestions for how I could have improved this solution, feel free to drop me a line using the links in the footer."}],"markDefs":[],"style":"normal"}],"image":{"images":{"sources":[],"fallback":{"src":"https://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=910&h=607&auto=format","srcSet":"https://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?rect=0,0,910,606&w=320&h=213&auto=format 320w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=654&h=436&auto=format 654w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=768&h=512&auto=format 768w,\nhttps://cdn.sanity.io/images/aaw5oc1t/production/409f0d4f18418aabdca5c75e913a2664cf3bef99-910x607.jpg?w=910&h=607&auto=format 910w","sizes":"(min-width: 910px) 910px, 100vw"}},"layout":"constrained","width":910,"height":607,"placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAABAABBv/EACEQAAICAgEEAwAAAAAAAAAAAAECAxEABCESEyIxMnGB/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQL/xAAYEQEBAAMAAAAAAAAAAAAAAAAAAQIRIf/aAAwDAQACEQMRAD8A4jbGgqDsxF5DwT08A4PVeGDruPm/kDRH1mzyFy6m+4oouD7/ADBEg67GvK6vHUVcuD7Emq0zEwFjdWWywc1rIwB9ZYJf/9k="}}}},
    "staticQueryHashes": []}